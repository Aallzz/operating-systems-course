Банщиков Дмитрий Игоревич
terminspace userspace 
какие-то кольца защиты
ring 0 ring 1 ring 2

Что мы будем знать. Как происходит взаимодействие приложений tlnet itmo.ifmo.net 80, ABI.
Есть приложение и просто так нам хватает userspace, но можно его больше эксплуатировать, поэтому нужно залезать поглубже в terminspace.
ОС созданы для лучшей абстракции, для защиты данных процессов. Есть ОС специального назначения, а есть общегоназначения. Прикол-дырокол: В ядре макоси есть плюсы. 
RPC. Patch-level. MTU. pass tunnel discovery.

SSH-console
Робачевский 

userspace все что работает на непривелигерованных уровнях
HARDWARE - аппаратное обеспечений самый низкий уровень x86 ARM Mix...
Поверх ввсего этого работает ядро kernel-space, которое знает, как рабоает процессор, как работает память, создержит драйвера устройств, которые знают, как работают щины и прочее,между ними может лежать virualization
выше всего лежить userspace, в котором, например, может лежать chrome

Hardware
Virtualization
Kernel-space
/// системные вызовы systemcall /// Системные библиотеки ///
userspace

системные вызовы различны для различных ос.
Библиотечная функция не вызывает ядро для своей работы, а syscall вызыдвают
С точки зрения программиста из-за абстракции интерфейса ядра эти штуку не различимы. Для винды прикольно, потому что они часто меняются местами.В Linux около 350 syscalls. 
TLB cache
syscall ломает branch prediction
ELF

Рассмотрим большие куски ядра
Само ядро - монолитный бинарь, часто обозначается как просто K.
+-------------------------------+      +-----------------+
| K     |      |      |         |      |                 |
| Boot  |  VFS |  VM  |   NET   |      |                 |
|_______|______|______|_________| <----| User interface  |
|       |      |      |         |      |                 |
|Drivers| Virt | ARCH | syscall |      |                 |
| shed  |      |      |         |      |                 |
| irq   |      |      |         |      |                 |
|_______|______|______|_________|      +-----------------+

VM - virtual mem
VFS - virtual file sys
Virt - virtualization
ARCH - архитектурно-специфичный код

Вот chrome сам не один процесс, а может 50-60, например для работы с сетью, для работы с javamchine и все эти процессы называются IPC

Программы взаимодействуют через спец интерфейс syscalls, ядро берет на себя всю грязную работу.

надо вспомнить про sheduler
userspace сетевой стек

Рассматриваем Userspace
                 +-+------------
                 |K|   syscalls
+-+---------+----+-++-------------+ <------|
|U|         |       |             |        |
+-+         |  NSS  |  resolve    |        |
|           |       |             |        | Системные библиотеки
|-----------+-------+-------------|        |
| mem alloc |          libc       |        |
+-----------+-------+-------------+ <------|
|     boost         |     QT      | 
+-------------------+-------------+

active directory
NSS - name service switching 

Model OSI

Процесс - экзмепляр запущенного исполняемого файла
Процесс хранит ресурсы, сам образ программы 
он создает иллюзию, что все выечислительные ресурсы, файловая система наши.
Ядру почти все равно, что мы запустили 

Какие бывает ресурсы процесса
память
вычислительный контекст - собтвенно наш код - потоки
у каждого потока есть свой стек выполнения
tid|pid - thread id|process id

В Unix все есть файл

файловый дескриптор
IPC - как взаимодействуют процессы
Credentials

Сегмент TEXT - код (машинные инструкции)
Сегмент DATA - все глобальные, статичные переменные 
HEAP (free store) - она растет вверх 

    Kernel mem
+---------------+
|     STACK     |
|      ||       |
|      \/       |
|               |
+---------------+
|               |
|      /\       |
|      ||       |
|     HEAP      |
+---------------+
|     DATA      |
+---------------+
|     TEXT      |
+---------------+

man syscall - почитать

Немного кода

const pid_t pid = fork(); // man fork служит для создания новго процесса
if (pid == -1) {
    // hadle error
} 
if (!pid) {
    we are child
}
if (pid) {
    we are parent 
}
fork вызвали из libc
Системыне вызвы в случае ошибки возвращают -1, errno - туда записывается причина // man errno
man -k // маны по ключевому слову 
pid_t - правиьный тип, который возвращает fork (но вообще int)
Сделано, потому что должно быть портируемо 

жил был процесс
              |
              |
            fork(2)
           /       \
          /         \
       parent       child

struct task_struct;
но все, что мы можем получить от fork - это создание новго процесса

int main(int argc, char * argv[]) {
    char *newargv[] = {NULL, "hello", "world", NULL};
    char * newenviron[] = {NULL};
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <file-to-exec>\n", argc[0]);
        exit(EXIT_FAILURE);
    }
    newargv[0] = argv[1]'
    execve(argv[1], newargv. newenviron);
    perror("execve");
    exit(EXIT_FAILURE);
}

bash
read(fd) man execve
         pid = fork();
         if (pid) {         if (!pid) {
                                execve(man, "execve");
         }                  }
    
commads: execve, execle, fork, waitpid(изменение статуса процесса)

/////////////////////////////////////////////////////////////////////////////////////////

Внутри ядра есть таблица открытых дескрипторов, которая содержит все наши открыте файлы

            process table                          File table 
+------------------------------------+       +-------------------------+
|    +----------+--------------+     |       |     +---------------+   |   +---------------+
|    | fd falgs | file pointer |     |       | +-->|status flags   |---|-->| v-node i-node |
|    +----------+--------------+     |       | |   |   offset      |   |   +---------------+
|    |__________|______________|     |       | |   | v-node pointer|   |
|    |__________|______________| ----|-------|-+   +---------------+   |
|    |__________|______________| ----|------>|--+                      |
+------------------------------------+       |  +->................    |


Системный вызов dup(2)

fork с таблицей файловых дескрипторов 
копируем таблицу, получаем те же самые номера, которые ссылаются на один и те же структуры

Understanding the linux kernel by Daniel P Bovet & Marco Cesati
Intel 64 and IA-32 Architectures Software Developer's Manual volume 3
X86 Instruction Set Aechitecture by Tom SHanlex
What every programmer should know about memory by Ulrich Derepper
Юезопасное программирование на С и C++. Сиакорд

Минимальная адрессуемая единаца байт и пихаем ее просто побайтово
То есть память как массив, но есть проблемы, если мы будет хотеть работать с памятью в это ключе
Она страая, начала зарождаться еще до 70-ых хотелось бы использовать жесктеи диски как продолжение оперативной памяти пк. Проблемы:
- Нужно делить память между всеми процесми и если процессы понадобилось немного допольниьельой памяти, то нужно уметь дать ее ему. Вот могут возникунуть проблемы с фрашментацией. Пусть они процесс съел кб потом 500 байт дырка, потом снова кб. вот это проявление внешней фрагментации. (он не расположен линейно и поэтому не можем ее кормтить программе)
Нам хочется защищать память одного процесса от другого (такого способа нет).
*jit code 
три уровня доступа память read write exe ... W^X
Мы хотим запускать много процессов и заманчиво запускать столько процессов, чтобы суммарно они кушали больше чем есть в оперативке, для этого будет использовать жесткий диск
Наблюдение: Программы есть рабочий набор (working set) размер которого меньше чем выделенная память. Рабочий набор ~ 20% объема памяти. Хотим, чтобы эта часть была в оперативке, а остальное на жестком диске. 
Физическую адрессацию сложно поддерживать руками

char a[128 * 1024];

+-------------------------------+
|*****| 64 | ***** | 32 | * | 32| - память
+-------------------------------+
очевидно, что так не катит, потому что i-ый элемент долеж счиаться как a + i; я так понял, что это и есть сегментная организация памяти (по физическим адрессам)

Виртуальная память (виртуальные адреса)
В программе зашиты вирт адр - смещение относительно какого-то сегмента

+-------------------------------+
|*****| 64 | ***** | 32 | * | 32| - память
+-------------------------------+
      ^    ^
      |    |
      <---->
   База Сегмаента 

для того чтобы быстро все делать (тут просто операция сложения) регистр упра ОС, в котором написано знач сегмента. Когда обращ ядро беред смещение и получает физический адресс
MMU этим занимается 

Была память

+-------------------------------+
|/////|      |///////|          |- память
+-------------------------------+
      __________ - стролько требует наш процесс

Хотим разместить еще процесс
как же нам засунуть.

+-------------------------------+
|/////|///////|                 |- память
+-------------------------------+
что он сделает - переместит немного 

вроде это концепция умерла 

права доступа к разным участкам памяти. 
Вот с сегмнетом очевидно не катит (он больше чем участочек памяти процесса)

data stack code - ds, ss, cs; general purpose - вские сегменты 
права на стек - wr
для кода - e

вот например asm move использует виртуальные адресса
(вообще почитай ту бумажку на сто страниц, что есть у Сорокина)

Мы ядро. Работает мы не желе, у которого одни испольнительго ребро. ...

tls

проблема фрагментации осталась 
решение - маленькие сегменты (страницы)


->Model OSI

TCP HANDSHAPE

SYN -> SYN/ACR -> ACR

CISCO 
CCNA = ICM-1 + ICMND2

Richard Stevenson TCP/IP illustrated

telnet vk.com 80
SSH - secure shell (как ответ telnet, у которого нет никакой криптографии)
Клиент-серверная архитектура 
telnet -  

networking 101


telnet toy
    /etc/services

telnet vk.com 80
GET / HTTP/1.1
протокол HTTP 
Это данные прикладного уровня. Ядро сформировало tcp запрос.


Роутер смотрит в загаловке L2 по полю proto

DNS 

/etc/hosts - маппинг ip-адрессов и названий

dig nslookup 

корень - . - начало все базы данных TLD  .ru  .org .com - домены первого уровня 
dig vk.com.
DNS - клиент-серверная архитектура 
@ сервер имен с которого хоти получить запрос 
dig @K.ROOT-SERVERS
проблема курицы и яйца





Что-то про форкать и потоки
мультиплксирование вводы-выводы
