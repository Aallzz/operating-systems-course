" First task from Fefelov {{{

Домашка 1 [ревизия 4]:

Путь к файлу в Unix-подобных системах состоит из компонент, разделенных символом "/". Назовём "каноническим" путём к файлу среди множества возможных такой путь, в котором количество компонент минимально, а при равенстве количества компонент путь минимален лексикографически.

Напишите программу, которая принимает первым аргументом строку s и рекурсивно ищет файлы, в которых встречается эта строка, начиная с текущей директории, выводя канонические пути относительно текущей директории ко всем уникальным файлам, в которых строка нашлась. Порядок в котором вы выведете пути не важен.

Ожидается:
a. в stdout попадет только список найденных файлов (ошибки отправляются в stderr)
b. вы будете корректно обрабатывать ошибки -- никаких сегфолтов.
c. максимальная длина строки s -- 1024 символа
d. ограничения на файлы такие же как в ext4: максимальная длина пути -- 4096 байт, одного компонента -- 255
e. вы будете переходить по симлинкам
f. файлы с одинаковым inode считаются одним и тем же файлом
g. структура текущей директории и всех ее поддиректорий и ссылок находится в пределах одной файловой системы
h. вы будете пользоваться языком C стандарта, допустим, C11 (или наиболее близкого к нему в вашем компиляторе C) и POSIX.1-2008. Альтернативно: вы будете пользоваться языком C++ стандарта C++17, используя из STL только безобидные структуры данных и алгоритмы типа <vector>, <algorithm>, <unordered_map>, вот это всё; никакого ввода-вывода a-la C++, никаких дополнительных библиотек.
j. в корневой директории с кодом вашего решения можно будет запустить make и получить исполняемый файл с названием mygrep.

Примеры:
#!/bin/sh
echo a > file
echo z > file2
echo qa > file3
mkdir dir1
ln -s dir1 dir2
echo a > dir1/file

~/solution/mygrep a
stdout:
file
file3
dir1/file
Дедлайн:
$ date -d "+2 weeks"
Sat Apr  7 08:21:32 MSK 2018

"}}}

" First task from Dmitry Banschikov {{{
Сдача без штрафов: 7 апреля. Сдача со штрафом: 21 апреля

Необходимо написать упрощенный командный интерпретатор(shell).

shell должен:

    В бесконечном цикле, как настоящий shell
    Считывать со стандартного ввода программу, которую необходимо
    запустить, вместе с ее аргументами. Программа задается в виде полного пути до исполняемого файла.
    Выполнять заданную программу с заданными аргументами
    Дожидаться завершения программы и выводить в стандартный поток вывода код ее завершения
    Необходимо обрабатывать ошибки всех используемых системных вызовов
    Необходимо обрабатывать конец вводу со стандартного потока
"}}}

" Second task from Dmitry Banschikov {{{ 
Сдача без штрафов: 7 апреля. Сдача со штрафом: 21 апреля

Необходимо написать подмножество утилиты find.

Программа должна:

    Первым аргументом принимать абсолютный путь, в котором будет производиться поиск файлов
    По-умолчанию выводить в стандартный поток вывода все найденные файлы по этому пути
    Поддерживать аргумент -inum num. Аргумент задает номер инода
    Поддерживать аргумент -name name. Аргумент задает имя файла
    Поддерживать аргумент -size [-=+]size. Аргумент задает фильтр файлов по размеру(меньше, равен, больше)
    Поддерживать аргумент -nlinks num. Аргумент задает количество hardlink'ов у файлов
    Поддерживать аргумент -exec path. Аргумент задает путь до исполняемого файла, которому в качестве единственного аргумент нужно передать найденный в иерархии файл
    Поддерживать комбинацию аргументов. Например хочется найти все файлы с размером больше 1GB и скормить их утилите /usr/bin/sha1sum.
    Выполнять поиск рекурсивно, в том числе во всех вложенных директориях.

Сильные духом призываются к выполнению задания с использованием системного вызова getdents(2). Остальные могут использовать readdir и opendir для чтения содержимого директории.
"}}}

" Third task from Dmitry Banschikov {{{
Сдача без штрафов: 14 апреля. Сдача со штрафом: 28 апреля

Кусочек JIT компилятора

Программа должна:

    Выделить память с помощью mmap(2)
    Записать в выделенную память машинный код, соответсвующий какой-либо функции
    Изменить права на выделенную память - чтение и исполнение. See: mprotect(2)
    Вызвать функцию по указателю на выделенную память
    Освободить выделенную память

Что может помочь при выполнении задания?

    man mmap(2), munmap(2), mprotect(2)
    GDB: help disassemble
    man objdump

Сильные духом призываются к возможности модификации кода выполняемой функции в runtime. Например, вы можете получить аргументом вызова вашей программы какое-то число и пропатчить машинный код этим числом. Эта часть задания будет оцениваться дополнительно в два балла.
" }}}

" Fourth task from Dmitry Banschikov {{{
Сдача без штрафов: 25 апреля. Сдача со штрафом: 9 мая

Необходимо создать статическую, и две динамических библиотеки и программу, которая будет их использовать.

Помимо этого нужен Makefile, с помощью которого можно будет собрать все части.

Статическая библиотека должна:

    Собираться статически
    Предоставлять какие-то функции

Первая динамическая библиотека должна:

    Собираться динамически
    Динамически линковаться с программой на этапе линковки
    Предоставлять какие-то функции

Вторая динамическая библиотека должна:

    Собираться динамически
    Предоставлять какие-то функции

Программа должна

    Статически линковаться с статической библиотекой и вызывать предоставляемые ей функции
    Динамически линковаться с первой динамической библиотекой и вызывать предоставляемые ей функции
    Во время выполнения в явном виде загружать вторую динамическию библиотеку с помощью dlopen(3) и вызывать какие-то функции из нее

Что может помочь при выполнении задания?

    man dlopen(3), man ld(1), man gcc(1)
"}}}

" Fifth task from Dmitry Banschikov {{{
Сдача без штрафов: 29 апреля. Сдача со штрафом: 10 мая

Необходимо попробовать клиент-серверное взаимодействие через синхронные сокеты.

Помимо этого нужен Makefile, с помощью которого можно будет собрать клиент и сервер.

Семейство протоколов для использования на выбор: AF_UNIX, AF_INET, AF_INET6

Сервер должен:

    В качестве аргументов принимать адрес, на котором будет ожидать входящих соединений.
    Стартовать, делать bind(2) на заданный адрес и ожидать входящих соединений
    При получении соединения, выполнять серверную часть придуманного вами протокола
    После обработки принятого соединения возвращаться в режим ожидания входящих соединений

Клиент должен:

    Принимать параметром адрес, к которому стоит подключиться
    Выполнять клиентскую часть придуманного вами протокола
    Завершаться

Для сильных духом предлагается выбрать какой-то существующий протокол и имплементировать его, или его разумное подмножество.

Сильность духа будет оцениваться в два балла, при условии что выбранный протокол сложнее чем ECHO(https://tools.ietf.org/html/rfc862).

}}}

Что-то дополнительно wireshark (если что, впомни чувака, который тебя приглашал, он был в синей куртке)
WebServer
Ядерный модуль для линукс для перехвата сисколов 
pe files 

Трасировщик машинных инструкций с ptrace 
linux divice linux 
